# -*- coding: utf-8 -*-
"""Football_env.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cKf6T-t7YYf22huSlhhf9Uuk3gMurKmZ
"""

import numpy as np

class Football:  # The class encapsulating the environment
    '''
    Actions [0 : Stand, 1 : Up, 2 : Right, 3 : Down, 4 : Left]
    These are the representing no.s for the mentioned actions
    '''

    def __init__(self, length=8, width=8, goalPositions=[2, 6]):
        
        # The players start at random locations
        pA=[np.random.randint(length), np.random.randint(length)] 
        pB=[np.random.randint(length), np.random.randint(length)]
        
        self.h = length   # Length of the Football Pitch    
        self.w = width    # Width of the Football Pitch
        # PS: We know the ratio of Length: Width is not 1:2, but they have been chosen keeping in mind the computational feasibility. 
        
        self.goalPositions = np.array(goalPositions)   # This means that the middle 4 positions at the right and left are the goals
        
        self.positions = np.array([pA, pB])            # This array stores the positions of the both the players
        
        self.initPositions = np.array([pA, pB])        # This array stores the initial position of both the players
        
        self.ballOwner = np.random.randint(2)          # Randomly, one of the players will be given the ball
        
        self.reward = 0                                # Initially the reward is 0
        
        # We have kept the observation list empty because we don't want to bias the choice of the participant for the State Space.
        self.observation = []
        
        self.done = 0                                   # This stores whether the game needs to be restart with new position (in the case of a goal)

    def reset(self):
        self.done = 0
        self.reward = 0
        
        self.initPositions[0] = [np.random.randint(self.h), np.random.randint(self.h)]
        self.initPositions[1] = [np.random.randint(self.h), np.random.randint(self.h)]
        ballOwner = self.choosePlayer()

        self.positions = self.initPositions.copy()
        self.ballOwner = ballOwner

    def step(self, actionA, actionB):
        if self.done == 1:
          self.reset()
          
        first = self.choosePlayer()
        actions = [actionA, actionB]
        self.move(first, actions[first])                   # We chose the first player at random
        if self.done == 1:
          return self.observation, self.reward, self.done
        self.move(1 - first, actions[1 - first])

        return self.observation, self.reward, self.done

    def move(self, player, action):
        opponent = 1 - player
        newPosition = self.positions[player] + self.actionToMove(action)

        # If it's opponent position
        if (newPosition == self.positions[opponent]).all():
            self.ballOwner = opponent
        # If it's a goal
        elif self.ballOwner is player and self.isInGoal(*newPosition) >= 0:
            self.done = 1
            return 1 - self.isInGoal(*newPosition)
        # If it's in the board
        elif self.isInBoard(*newPosition):
            self.positions[player] = newPosition
        return -1

    def actionToMove(self, action):
        switcher = {
            0: [0, 0],
            1: [0, 1],
            2: [1, 0],
            3: [0, -1],
            4: [-1, 0],
        }
        return switcher.get(action)

    def isInGoal(self, x, y):
        g1, g2 = self.goalPositions
        if (g1 <= y <= g2):
            if x == -1:
                self.done = 1
                self.reward = -1 # if the ball reaches the right goal post, then the rewards shall be -1
                return 1 
            elif x == self.w:
                self.done = 1
                self.reward = 1 # if the ball reaches the right goal post, then the rewards shall be 1
                return 0
        return -1

    def isInBoard(self, x, y):
        return (0 <= x < self.w and 0 <= y < self.h)

    def choosePlayer(self):
        return np.random.randint(0, 2)

    def render(self, positions=None, ballOwner=None):
        positions = self.positions if positions is None else np.array(positions)
        ballOwner = self.ballOwner if ballOwner is None else ballOwner

        board = ''
        for y in range(self.h)[::-1]:
            for x in range(self.w):
                if ([x, y] == positions[0]).all():
                    board += 'A' if ballOwner is 0 else 'a'
                elif ([x, y] == positions[1]).all():
                    board += 'B' if ballOwner is 1 else 'b'
                else:
                    board += '-'
            board += '\n'

        print(board)

